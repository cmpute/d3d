from enum import Enum
import numpy
from typing import Dict, Iterable, List, Union, Optional
from d3d.abstraction import Target3DArray, TransformSet

TClass = Union[Enum, int]

class DetectionEvalStats:
    @property
    def ngt(self) -> Dict[int, int]: ...
    @property
    def tp(self) -> Dict[int, List[int]]: ...
    @property
    def fp(self) -> Dict[int, List[int]]: ...
    @property
    def fn(self) -> Dict[int, List[int]]: ...
    @property
    def ndt(self) -> Dict[int, List[int]]: ...
    @property
    def acc_iou(self) -> Dict[int, List[float]]: ...
    @property
    def acc_angular(self) -> Dict[int, List[float]]: ...
    @property
    def acc_dist(self) -> Dict[int, List[float]]: ...
    @property
    def acc_box(self) -> Dict[int, List[float]]: ...
    @property
    def acc_var(self) -> Dict[int, List[float]]: ...

    def as_object(self) -> dict: ...

class DetectionEvaluator:
    def __init__(self,
                 classes: Union[Enum, Iterable[Enum]],
                 min_overlaps: Union[float, Iterable[float]],
                 pr_sample_count: int = 40,
                 min_score: float = 0.,
                 pr_sample_scale: str = "log10"): ...

    def reset(self) -> None: ...
    def calc_stats(self, gt_boxes: Target3DArray, dt_boxes: Target3DArray,
                         calib: TransformSet = None) -> DetectionEvalStats: ...
    def add_stats(self, stats: DetectionEvalStats) -> None: ...
    def get_stats(self) -> DetectionEvalStats: ...

    @property
    def score_thresholds(self) -> numpy.ndarray: ...
    def gt_count(self) -> int: ...
    def dt_count(self, score: float = float('nan')) -> Dict[Enum, int]: ...
    def tp(self, score: float = float('nan')) -> Dict[Enum, int]: ...
    def fp(self, score: float = float('nan')) -> Dict[Enum, int]: ...
    def fn(self, score: float = float('nan')) -> Dict[Enum, int]: ...

    def precision(self, score: float = float('nan'), return_all: bool = False)\
        -> Dict[Enum, Union[float, List[float]]]: ...
    def recall(self, score: float = float('nan'), return_all: bool = False)\
        -> Dict[Enum, Union[float, List[float]]]: ...
    def fscore(self, score: float = float('nan'), beta:float = 1, return_all: bool = False)\
        -> Dict[Enum, Union[float, List[float]]]: ...
    def ap(self) -> Dict[Enum, float]: ...

    def acc_iou(self, score: float = float('nan')) -> Dict[Enum, float]: ...
    def acc_box(self, score: float = float('nan')) -> Dict[Enum, float]: ...
    def acc_dist(self, score: float = float('nan')) -> Dict[Enum, float]: ...
    def acc_angular(self, score: float = float('nan')) -> Dict[Enum, float]: ...

    def summary(self, score_thres: float = 0.8) -> str: ...

class TrackingEvalStats(DetectionEvalStats):
    @property
    def id_switches(self) -> Dict[int, List[int]]: ...
    @property
    def fragments(self) -> Dict[int, List[int]]: ...

    @property
    def ngt_ids(self) -> Dict[int, Dict[int, int]]: ...
    @property
    def ngt_tracked(self) -> Dict[int, List[Dict[int, int]]]: ...
    @property
    def ndt_ids(self) -> Dict[int, List[Dict[int, int]]]: ...

    def as_object(self) -> dict: ...

class TrackingEvaluator(DetectionEvaluator):
    def __init__(self,
                 classes: Union[Enum, Iterable[Enum]],
                 min_overlaps: Union[float, Iterable[float]],
                 pr_sample_count: int = 40,
                 min_score: float = 0.,
                 pr_sample_scale: str = "log10"): ...

    def reset(self) -> None: ...
    def calc_stats(self, gt_boxes: Target3DArray, dt_boxes: Target3DArray,
                         calib: TransformSet = None) -> TrackingEvalStats: ...
    def add_stats(self, stats: TrackingEvalStats) -> None: ...
    def get_stats(self) -> TrackingEvalStats: ...

    def id_switches(self, score: float = float('nan')) -> Dict[Enum, float]: ...
    def fragments(self, score: float = float('nan')) -> Dict[Enum, float]: ...
    def gt_traj_count(self) -> Dict[Enum, int]: ...

    def tracked_ratio(self, score: float = float('nan'),
        frame_ratio_threshold: float = 0.8,
        return_all: bool = False) -> Dict[Enum, Union[float, List[float]]]: ...
    def lost_ratio(self, score: float = float('nan'),
        frame_ratio_threshold: float = 0.2,
        return_all: bool = False) -> Dict[Enum, Union[float, List[float]]]: ...
    def mota(self, score: float = float('nan')) -> Dict[Enum, float]: ...

    def summary(self, score_thres: float = 0.8) -> str: ...

class SegmentationStats:
    @property
    def tp(self) -> Dict[int, int]: ...
    @property
    def fp(self) -> Dict[int, int]: ...
    @property
    def fn(self) -> Dict[int, int]: ...

    @property
    def itp(self) -> Dict[int, int]: ...
    @property
    def ifp(self) -> Dict[int, int]: ...
    @property
    def ifn(self) -> Dict[int, int]: ...

    @property
    def cumiou(self) -> Dict[int, float]: ...

    def as_object(self) -> dict: ...

class SegmentationEvaluator:
    def __init__(self,
                 classes: Union[TClass, Iterable[TClass]],
                 background: TClass,
                 min_points: int): ...

    def reset(self) -> None: ...
    def calc_stats(self, gt_labels: numpy.ndarray, dt_boxes: numpy.ndarray,
                         gt_ids: Optional[numpy.ndarray], dt_ids: Optional[numpy.ndarray]) -> SegmentationStats: ...
    def add_stats(self, stats: SegmentationStats) -> None: ...
    def get_stats(self) -> SegmentationStats: ...

    def tp(self) -> Dict[TClass, int]: ...
    def fp(self) -> Dict[TClass, int]: ...
    def fn(self) -> Dict[TClass, int]: ...
    def itp(self) -> Dict[TClass, int]: ...
    def ifp(self) -> Dict[TClass, int]: ...
    def ifn(self) -> Dict[TClass, int]: ...

    def iou(self) -> Dict[TClass, float]: ...
    def sq(self) -> Dict[TClass, float]: ...
    def rq(self) -> Dict[TClass, float]: ...
    def pq(self) -> Dict[TClass, float]: ...
